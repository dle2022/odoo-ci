name: Clone Prod → Staging 2

on:
  workflow_dispatch:
    inputs:
      which_backup:
        description: "Which backup to use"
        type: choice
        options: [latest, explicit_path]
        default: latest
      backup_path:
        description: "Absolute path to an existing prod .tar.gz (when which_backup=explicit_path)"
        required: false
      transfer:
        description: "How to move the backup from prod job to staging job"
        type: choice
        options: [local, artifact]
        default: local

permissions:
  contents: read

jobs:
  make_prod_backup:
    name: Make/Select Prod Backup
    runs-on: [self-hosted, production]
    environment: production
    outputs:
      backup_path: ${{ steps.mk.outputs.path }}

    steps:
      - uses: actions/checkout@v4

      # Rehydrate the SAME env file/secret as your working "Backup Odoo" job
      - name: Rehydrate prod env
        shell: bash
        run: |
          set -euo pipefail
          [[ -n "${{ secrets.ENV_PROD_B64 }}" ]] || { echo "ENV_PROD_B64 empty"; exit 90; }
          printf '%s' "${{ secrets.ENV_PROD_B64 }}" | base64 -d > .env.prod
          sed -i 's/\r$//' .env.prod || true

      - name: Create/Select backup
        id: mk
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ inputs.which_backup }}" == "explicit_path" ]]; then
            P="${{ inputs.backup_path }}"
            [[ -n "$P" && -f "$P" ]] || { echo "Given backup_path not found: $P"; exit 2; }
            echo "path=$P" >> "$GITHUB_OUTPUT"
            echo "Using existing backup: $P"
          else
            chmod +x scripts/backup_docker.sh
            OUT=$(./scripts/backup_docker.sh prod | awk -F= '/^BACKUP_PATH=/{print $2}')
            [[ -n "$OUT" && -f "$OUT" ]] || { echo "Backup path not produced"; exit 3; }
            echo "path=$OUT" >> "$GITHUB_OUTPUT"
            echo "Created fresh backup: $OUT"
          fi

      # Only needed when prod & staging are on different machines
      - name: Upload backup as artifact (cross-host)
        if: ${{ inputs.transfer == 'artifact' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ github.run_id }}-prod-backup
          path: ${{ steps.mk.outputs.path }}

  restore_to_staging:
    name: Restore to Staging
    needs: make_prod_backup
    runs-on: [self-hosted, staging]
    environment: staging

    steps:
      - uses: actions/checkout@v4
      - name: Rehydrate prod backup env
        shell: bash
        run: |
          set -euo pipefail
          [[ -n "${{ secrets.ENV_PROD_B64 }}" ]] || { echo "ENV_PROD_B64 empty"; exit 90; }
          printf '%s' "${{ secrets.ENV_PROD_B64 }}" | base64 -d > .env.backup.prod
          sed -i 's/\r$//' .env.backup.prod || true

      # Rehydrate BOTH envs on the staging runner if your clone script reads them locally
      - name: Rehydrate staging env
        shell: bash
        run: |
          set -euo pipefail
          [[ -n "${{ secrets.ENV_STAGING_B64 }}" ]] || { echo "ENV_STAGING_B64 empty"; exit 91; }
          printf '%s' "${{ secrets.ENV_STAGING_B64 }}" | base64 -d > .env.staging
          sed -i 's/\r$//' .env.staging || true

      # ---------- ARTIFACT path (for cross-host) ----------
      - name: Download backup artifact (cross-host)
        if: ${{ inputs.transfer == 'artifact' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ github.run_id }}-prod-backup
          path: ${{ runner.temp }}/backup

      - name: Set restore path (artifact)
        if: ${{ inputs.transfer == 'artifact' }}
        id: setpath_artifact
        shell: bash
        run: |
          set -euo pipefail
          P=$(ls -1 "${{ runner.temp }}/backup/"*.tar.gz | head -1 || true)
          [[ -n "$P" && -f "$P" ]] || { echo "Artifact tar.gz not found"; exit 12; }
          echo "path=$P" >> "$GITHUB_OUTPUT"
          echo "Using artifact: $P"

      # ---------- LOCAL path (same host shared dir) ----------
      - name: Set restore path (local)
        if: ${{ inputs.transfer == 'local' }}
        id: setpath_local
        shell: bash
        run: |
          set -euo pipefail
          P="${{ needs.make_prod_backup.outputs.backup_path }}"
          [[ -n "$P" && -f "$P" ]] || { echo "Local shared path not found: $P"; exit 11; }
          echo "path=$P" >> "$GITHUB_OUTPUT"
          echo "Using local shared path: $P"

      # ---------- Restore using whichever path we set ----------
      - name: Clone Prod → Staging
        shell: bash
        run: |
          set -euo pipefail
          chmod +x scripts/clone_prod_to_staging_2.sh
          # prefer artifact path if present, otherwise use local
          PATH_FROM_STEP="${{ steps.setpath_artifact.outputs.path || steps.setpath_local.outputs.path }}"
          [[ -n "$PATH_FROM_STEP" ]] || { echo "No restore path set"; exit 13; }
          ./scripts/clone_prod_to_staging_2.sh --from "$PATH_FROM_STEP"
